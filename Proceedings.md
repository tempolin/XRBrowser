いい整理タイミングです。
今まで貼ってくれた **Unity側 + Java側の全コード**を前提に、
**「Quest 3でメモリが苦しくなる／増えて見える原因」**を **事実ベースで列挙**します。
（対策は書かず、まず「何が問題か」だけ）

---

# 問題点の列挙（重要度順）

## 【P0：致命的・最優先】

### 1️⃣ JNIで `byte[]` を戻り値として返している

* `bridge.Call<byte[]>("captureRgba")`
* Java側では `rgbaBuf` を再利用していても
  **JNI境界で Unity(C#) 側に毎フレーム新しい byte[] が生成・コピーされる**
* 結果：

  * 1024×1024×4 ≒ 4MB
  * 10fps → **秒40MB規模の一時メモリ**
  * GCが追いつかず「メモリが増えて落ちる」

👉 **「増え続ける」最大の原因**

---

## 【P1：高リスク】

### 2️⃣ CPUキャプチャ方式そのものが重い

* `webView.draw(canvas)`
* `bitmap.getPixels(...)`
* `int[] → byte[]` 変換ループ

すべて **CPU処理 + メモリ帯域消費**
Quest（統合メモリ）では非常に不利。

👉 メモリだけでなく **帯域・CPU時間**も圧迫

---

### 3️⃣ `captureRgba()` 内で毎回小オブジェクトを new している

```java
new Object()
new boolean[]{false}
```

* 小さいが **毎フレーム**
* GC頻度が上がる
* フレーム落ち → キュー滞留 → メモリピーク増

---

## 【P2：中リスク】

### 4️⃣ Bitmap を recycle していない

* `bitmap = null` だけ
* ネイティブ側メモリが即座に返らない可能性あり

👉 長時間実行やシーン再生成で効いてくる

---

### 5️⃣ Unity側で `Texture2D` に毎フレーム `Apply()`

* `LoadRawTextureData`
* `Apply(false, false)`

これは設計上必要だが

* CPU→GPU転送が毎フレーム
* 統合メモリ帯域を常時消費

👉 「GPUで描画してるのに軽くならない」原因

---

## 【P3：低〜中リスク（積み重なると効く）】

### 6️⃣ `targetRenderer.material` によるマテリアル複製

* `renderer.material` は **インスタンスを新規生成**
* シーン再生成や複数WebQuadで増殖しやすい

---

### 7️⃣ 入力同期（XRI Keyboard → WebView）が高頻度

* `setFocusedInputValue` を短周期で呼ぶ
* JS実行 → DOM更新 → レイアウト発生
* WebViewが重くなる → キャプチャも遅れる

👉 メモリというより **負荷増幅要因**

---

### 8️⃣ 解像度が高め（1024×1024 RGBA）

* 1枚 ≒ 4MB
* Passthrough / XR compositor と競合

👉 余裕がない状況で一気に危険域に入る

---

# まとめ（重要な因果関係）

**「メモリが増える」直接原因**

> **① JNI byte[] 戻り値
> ＋ ② CPUキャプチャ方式**

**「落ちやすくする増幅要因」**

> ③〜⑧ が重なってピークを押し上げている

---

## 次の整理ステップ（おすすめ）

次はこの3択に進むのが一番わかりやすいです。

1️⃣ **今すぐ直す最小構成（P0だけ潰す）**
2️⃣ **CPUキャプチャ前提で“安全な設計”にする**
3️⃣ **構造を変えてGPU直結に寄せる（WebView卒業）**

どれから行くか、番号で指定してもらえれば
そのレベルに合わせて **設計図 → 修正コード** をまとめます。
