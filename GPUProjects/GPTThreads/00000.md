了解。
このスレッド全体を **「何をやろうとして、何が分かって、今どこにいるか」** が一目で分かる形でまとめます。

---

# このスレッドのまとめ（技術・判断・現在地）

## 目的（最初から一貫しているゴール）

**Quest上で Chromium 系ブラウザ（Android WebView）を
Unity の中に表示し、GPUパスで 30fps 以上・入力付きで動かすこと。**

* 他アプリの画面共有が主目的ではない
* 「Unity内ブラウザ」が本命

---

## 全体像（最終的に目指す構成）

```
Android WebView（Chromium）
   ↓（描画）
Surface / VirtualDisplay
   ↓
ImageReader(PRIVATE)
   ↓
HardwareBuffer   ←★ここを確認済み
   ↓
EGLImageKHR
   ↓
GL_TEXTURE_EXTERNAL_OES
   ↓
Unity Native Plugin
   ↓
Unity Texture（30/60fps）
```

---

## チェックポイント（CP）で何をやったか

### CP0：Android単体でWebViewが動くか

* Unityなし
* 普通のWebView表示
* 👉 問題なし（前提OK）

---

### CP1：Presentation + VirtualDisplay が生きているか

* VirtualDisplay を作成
* Presentation に UI を描画
* tick（カウントアップ）で更新確認
* 👉 **成功**

---

### CP2：VirtualDisplay → ImageReader(PRIVATE) がつながるか

* ImageReader(PRIVATE)
* acquireLatestImage()
* HardwareBuffer != null を確認
* 👉 **成功（hb=true を実機で確認）**

これはかなり重要で、
**GPU直結パイプラインが成立することを実証済み。**

---

### CP2.5：60fpsで回るか？

* Presentation を 16ms tick
* fps 計測
* 結果：

  * Presentation は動く
  * ImageReader 側は 1〜数fps程度

👉 **Quest OS の VirtualDisplay 合成制限によるもの**
👉 ここで詰まるのは仕様寄りで、失敗ではない

**重要な判断：**

> fps を Android 側で追わなくていい
> fps は Unity 側で作る

---

## MediaProjection に関する整理（重要な誤解の解消）

### MediaProjection とは？

* OS画面・他アプリを **“盗み見る”** 画面キャプチャAPI
* 画面共有・録画用
* ユーザー許可ダイアログ必須
* 重い・制限が多い

### 今やっている手法とは？

* **自分で描いたものを取る**
* オフスクリーンレンダリング
* GPU直結
* Unity向き

### 結論

* **範囲が広い** → MediaProjection
* **軽くて速い** → 今の手法
* Unity内ブラウザ目的なら **MediaProjectionは不要**

---

## 他アプリを表示したい話について

* VirtualDisplay を作っても **他アプリを勝手に出すことはできない**
* 他アプリを取りたいなら MediaProjection が必要
* 今回の目的（Chromium in Unity）とは別物

---

## 途中で出たエラーの正体

```
SecurityException:
Requires CAPTURE_VIDEO_OUTPUT ...
```

* Quest / Android 13+ の DisplayManager 実装の癖
* 特定の VirtualDisplay フラグ構成で

  * 「画面キャプチャ用途」と誤判定される
* MediaProjection必須という意味ではない

👉 **だから「安定構成」に戻す判断は正しい**

---

## 現在地（いまここ）

### 達成済み

* ✅ Presentation 描画 OK
* ✅ VirtualDisplay 作成 OK
* ✅ ImageReader(PRIVATE) OK
* ✅ HardwareBuffer 取得 OK（hb=true）

これは **PoCとしては成功レベル**。

---

## 今選んだ正しい方針

* fps検証・MediaProjectionは一旦捨てる
* **CP2が安定して通る構成に戻す**
* 次は **CP3（GPU変換）に進む**

👉 この判断は **最短・最安全ルート**。

---

## 次のステップ（CP3）

**Android NDK / EGL でやること：**

1. EGLContext 作成
2. HardwareBuffer → EGLImageKHR
3. GL_TEXTURE_EXTERNAL_OES を生成
4. Unity Native Plugin に textureId を渡す

ここが「Unityに貼れるかどうか」の本番。

---

## 一言でまとめると

> **VirtualDisplayは“確認用の足場”
> 本命は HardwareBuffer → EGL → Unity**

ここまで来てるのは本当にすごいところまで来てる。
次は **CP3（黒画面にならないEGL最小コード）**を出せるけど、行く？

